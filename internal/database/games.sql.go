// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: games.sql

package database

import (
	"context"
	"database/sql"
)

const getBoardForGame = `-- name: GetBoardForGame :one
WITH gids AS (
    SELECT gid
    FROM users_games
    WHERE uid = ?
)
SELECT id, subject1, subject2, subject3, subject4
FROM boards
WHERE id NOT IN (
    SELECT bid
    FROM games
    WHERE id IN gids
)
LIMIT 1
`

type GetBoardForGameRow struct {
	ID       int64
	Subject1 sql.NullInt64
	Subject2 sql.NullInt64
	Subject3 sql.NullInt64
	Subject4 sql.NullInt64
}

func (q *Queries) GetBoardForGame(ctx context.Context, uid int64) (GetBoardForGameRow, error) {
	row := q.db.QueryRowContext(ctx, getBoardForGame, uid)
	var i GetBoardForGameRow
	err := row.Scan(
		&i.ID,
		&i.Subject1,
		&i.Subject2,
		&i.Subject3,
		&i.Subject4,
	)
	return i, err
}

const getGameUidByGameId = `-- name: GetGameUidByGameId :one
SELECT uid
FROM users_games
WHERE gid = ?
LIMIT 1
`

func (q *Queries) GetGameUidByGameId(ctx context.Context, gid int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, getGameUidByGameId, gid)
	var uid int64
	err := row.Scan(&uid)
	return uid, err
}

const getSubjects = `-- name: GetSubjects :many
SELECT name, word1, word2, word3, word4 FROM subjects
`

type GetSubjectsRow struct {
	Name  string
	Word1 int64
	Word2 int64
	Word3 int64
	Word4 int64
}

func (q *Queries) GetSubjects(ctx context.Context) ([]GetSubjectsRow, error) {
	rows, err := q.db.QueryContext(ctx, getSubjects)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSubjectsRow
	for rows.Next() {
		var i GetSubjectsRow
		if err := rows.Scan(
			&i.Name,
			&i.Word1,
			&i.Word2,
			&i.Word3,
			&i.Word4,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubjectsForBoard = `-- name: GetSubjectsForBoard :many
WITH first AS (
    SELECT id, name, word1, word2, word3, word4
    FROM subjects
    ORDER BY random()
    LIMIT 1
),
second AS (
    SELECT id, name, word1, word2, word3, word4
    FROM subjects
    WHERE NOT EXISTS (
        SELECT 1
        FROM first
        WHERE first.word1 IN (subjects.word1, subjects.word2, subjects.word3, subjects.word4)
        OR first.word2 IN (subjects.word1, subjects.word2, subjects.word3, subjects.word4)
        OR first.word3 IN (subjects.word1, subjects.word2, subjects.word3, subjects.word4)
        OR first.word4 IN (subjects.word1, subjects.word2, subjects.word3, subjects.word4)
    )
    ORDER BY random()
    LIMIT 1
),
third AS (
    SELECT id, name, word1, word2, word3, word4
    FROM subjects
    WHERE NOT EXISTS (
        SELECT 1
        FROM first
        WHERE first.word1 IN (subjects.word1, subjects.word2, subjects.word3, subjects.word4)
        OR first.word2 IN (subjects.word1, subjects.word2, subjects.word3, subjects.word4)
        OR first.word3 IN (subjects.word1, subjects.word2, subjects.word3, subjects.word4)
        OR first.word4 IN (subjects.word1, subjects.word2, subjects.word3, subjects.word4)
        UNION
        SELECT 1
        FROM second
        WHERE second.word1 IN (subjects.word1, subjects.word2, subjects.word3, subjects.word4)
        OR second.word2 IN (subjects.word1, subjects.word2, subjects.word3, subjects.word4)
        OR second.word3 IN (subjects.word1, subjects.word2, subjects.word3, subjects.word4)
        OR second.word4 IN (subjects.word1, subjects.word2, subjects.word3, subjects.word4)
    )
    ORDER BY random()
    LIMIT 1
),
fourth AS (
    SELECT id, name, word1, word2, word3, word4
    FROM subjects
    WHERE NOT EXISTS (
        SELECT 1
        FROM first
        WHERE first.word1 IN (subjects.word1, subjects.word2, subjects.word3, subjects.word4)
        OR first.word2 IN (subjects.word1, subjects.word2, subjects.word3, subjects.word4)
        OR first.word3 IN (subjects.word1, subjects.word2, subjects.word3, subjects.word4)
        OR first.word4 IN (subjects.word1, subjects.word2, subjects.word3, subjects.word4)
        UNION
        SELECT 1
        FROM second
        WHERE second.word1 IN (subjects.word1, subjects.word2, subjects.word3, subjects.word4)
        OR second.word2 IN (subjects.word1, subjects.word2, subjects.word3, subjects.word4)
        OR second.word3 IN (subjects.word1, subjects.word2, subjects.word3, subjects.word4)
        OR second.word4 IN (subjects.word1, subjects.word2, subjects.word3, subjects.word4)
        UNION
        SELECT 1
        FROM third
        WHERE third.word1 IN (subjects.word1, subjects.word2, subjects.word3, subjects.word4)
        OR third.word2 IN (subjects.word1, subjects.word2, subjects.word3, subjects.word4)
        OR third.word3 IN (subjects.word1, subjects.word2, subjects.word3, subjects.word4)
        OR third.word4 IN (subjects.word1, subjects.word2, subjects.word3, subjects.word4)
    )
    ORDER BY random()
    LIMIT 1
)
SELECT id FROM first
UNION ALL
SELECT id FROM second
UNION ALL
SELECT id FROM third
UNION ALL
SELECT id FROM fourth
`

func (q *Queries) GetSubjectsForBoard(ctx context.Context) ([]int64, error) {
	rows, err := q.db.QueryContext(ctx, getSubjectsForBoard)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const saveBoardToGame = `-- name: SaveBoardToGame :exec
UPDATE games
SET bid = ?
WHERE id = ?
`

type SaveBoardToGameParams struct {
	Bid sql.NullInt64
	ID  int64
}

func (q *Queries) SaveBoardToGame(ctx context.Context, arg SaveBoardToGameParams) error {
	_, err := q.db.ExecContext(ctx, saveBoardToGame, arg.Bid, arg.ID)
	return err
}

const saveNewBoard = `-- name: SaveNewBoard :exec
INSERT INTO boards(subject1, subject2, subject3, subject4)
VALUES(?, ?, ?, ?)
`

type SaveNewBoardParams struct {
	Subject1 sql.NullInt64
	Subject2 sql.NullInt64
	Subject3 sql.NullInt64
	Subject4 sql.NullInt64
}

func (q *Queries) SaveNewBoard(ctx context.Context, arg SaveNewBoardParams) error {
	_, err := q.db.ExecContext(ctx, saveNewBoard,
		arg.Subject1,
		arg.Subject2,
		arg.Subject3,
		arg.Subject4,
	)
	return err
}

const saveNewGame = `-- name: SaveNewGame :one
INSERT INTO games(active, start)
VALUES (?, ?)
RETURNING id
`

type SaveNewGameParams struct {
	Active sql.NullBool
	Start  sql.NullInt64
}

func (q *Queries) SaveNewGame(ctx context.Context, arg SaveNewGameParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, saveNewGame, arg.Active, arg.Start)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const saveSubject = `-- name: SaveSubject :exec
INSERT INTO subjects(name, word1, word2, word3, word4)
VALUES (?, ?, ?, ?, ?)
`

type SaveSubjectParams struct {
	Name  string
	Word1 int64
	Word2 int64
	Word3 int64
	Word4 int64
}

func (q *Queries) SaveSubject(ctx context.Context, arg SaveSubjectParams) error {
	_, err := q.db.ExecContext(ctx, saveSubject,
		arg.Name,
		arg.Word1,
		arg.Word2,
		arg.Word3,
		arg.Word4,
	)
	return err
}

const saveUserToGame = `-- name: SaveUserToGame :exec
INSERT INTO users_games(uid, gid)
VALUES(?, ?)
`

type SaveUserToGameParams struct {
	Uid int64
	Gid int64
}

func (q *Queries) SaveUserToGame(ctx context.Context, arg SaveUserToGameParams) error {
	_, err := q.db.ExecContext(ctx, saveUserToGame, arg.Uid, arg.Gid)
	return err
}

const updateBoard = `-- name: UpdateBoard :exec
UPDATE boards
SET played = ?,
    wins = ?
WHERE id = ?
`

type UpdateBoardParams struct {
	Played sql.NullInt64
	Wins   sql.NullInt64
	ID     int64
}

func (q *Queries) UpdateBoard(ctx context.Context, arg UpdateBoardParams) error {
	_, err := q.db.ExecContext(ctx, updateBoard, arg.Played, arg.Wins, arg.ID)
	return err
}

const updateGame = `-- name: UpdateGame :exec
UPDATE games
SET active = ?,
    turns = ?,
    wrong = ?,
    win = ?,
    end = ?
WHERE id = ?
`

type UpdateGameParams struct {
	Active sql.NullBool
	Turns  sql.NullInt64
	Wrong  sql.NullInt64
	Win    sql.NullBool
	End    sql.NullInt64
	ID     int64
}

func (q *Queries) UpdateGame(ctx context.Context, arg UpdateGameParams) error {
	_, err := q.db.ExecContext(ctx, updateGame,
		arg.Active,
		arg.Turns,
		arg.Wrong,
		arg.Win,
		arg.End,
		arg.ID,
	)
	return err
}

const updateGameStatus = `-- name: UpdateGameStatus :exec
UPDATE games
SET win = ?,
    end = ?,
    active = ?
WHERE id = ?
`

type UpdateGameStatusParams struct {
	Win    sql.NullBool
	End    sql.NullInt64
	Active sql.NullBool
	ID     int64
}

func (q *Queries) UpdateGameStatus(ctx context.Context, arg UpdateGameStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateGameStatus,
		arg.Win,
		arg.End,
		arg.Active,
		arg.ID,
	)
	return err
}

const updateGameTurns = `-- name: UpdateGameTurns :exec
UPDATE games
SET turns = ?,
    wrong = ?
WHERE id = ?
`

type UpdateGameTurnsParams struct {
	Turns sql.NullInt64
	Wrong sql.NullInt64
	ID    int64
}

func (q *Queries) UpdateGameTurns(ctx context.Context, arg UpdateGameTurnsParams) error {
	_, err := q.db.ExecContext(ctx, updateGameTurns, arg.Turns, arg.Wrong, arg.ID)
	return err
}
